<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Music Visualizer</title>
  
  <!-- ==========================================
       MODULE CONFIGURATION
       ========================================== -->
  <script type="application/json" id="module-config">
  {
    "id": "music-visualizer",
    "name": "Music Visualizer",
    "priority": 999,
    "hasControllerUI": false,
    "hasOverlay": true,
    "overlayUrl": "/modules/music-visualizer.html",
    "dependencies": []
  }
  </script>
  
  <!-- ==========================================
       OBS OVERLAY STYLES
       ========================================== -->
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: transparent;
      font-family: Arial, sans-serif;
      color: white;
      display: flex;
      justify-content: flex-start;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
      overflow: hidden;
    }
    
    .now-playing {
      background: rgba(26, 26, 26, 0.95);
      border-radius: 20px;
      padding: 25px;
      display: flex;
      align-items: center;
      gap: 25px;
      min-width: 400px;
      max-width: 700px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      position: relative;
      transform: translateX(-150%);
      opacity: 0;
      transition: none;
      
      /* Rainbow border */
      padding: 4px;
      background: linear-gradient(
        90deg,
        #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3,
        #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3, #ff0000
      );
      background-size: 300% 100%;
      animation: rainbow-flow 15s linear infinite;
    }
    
    @keyframes rainbow-flow {
      0% { background-position: 0% 0%; }
      100% { background-position: 300% 0%; }
    }
    
    .now-playing-inner {
      background: rgba(26, 26, 26, 0.95);
      border-radius: 16px;
      padding: 20px;
      display: flex;
      align-items: center;
      gap: 25px;
      width: 100%;
    }
    
    /* Slide in from left */
    .now-playing.slide-in {
      animation: slideInFromLeft 1s ease-out forwards;
    }
    
    /* Slide out to right */
    .now-playing.slide-out {
      animation: slideOutToRight 1s ease-in forwards;
    }
    
    @keyframes slideInFromLeft {
      0% {
        transform: translateX(-150%);
        opacity: 0;
      }
      100% {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    @keyframes slideOutToRight {
      0% {
        transform: translateX(0);
        opacity: 1;
      }
      100% {
        transform: translateX(150%);
        opacity: 0;
      }
    }
    
    .album-cover {
      width: 120px;
      height: 120px;
      border-radius: 12px;
      background: linear-gradient(135deg, #1DB954, #1ed760);
      flex-shrink: 0;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 60px;
    }
    
    .album-cover img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .track-info {
      flex: 1;
      min-width: 0;
    }
    
    .track-name {
      font-size: 26px;
      font-weight: bold;
      margin-bottom: 10px;
      line-height: 1.3;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    .artist-name {
      font-size: 20px;
      opacity: 0.8;
      line-height: 1.3;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    .music-logo {
      font-size: 14px;
      opacity: 0.5;
      margin-top: 10px;
    }
    
    .hidden {
      display: none !important;
    }
    
    /* Audio player hidden */
    #audio-player, #audio-player-next {
      display: none;
    }
  </style>
</head>
<body>
  <!-- Audio players for Playlist module -->
  <audio id="audio-player" preload="auto"></audio>
  <audio id="audio-player-next" preload="auto"></audio>

  <!-- Now Playing Display -->
  <div class="now-playing" id="nowPlaying">
    <div class="now-playing-inner">
      <div class="album-cover" id="albumCover">
        ðŸŽµ
      </div>
      <div class="track-info">
        <div class="track-name" id="trackName">No music playing</div>
        <div class="artist-name" id="artistName">Start music to see info</div>
        <div class="music-logo" id="musicSource">ðŸŽµ Music</div>
      </div>
    </div>
  </div>

  <!-- ==========================================
       OBS OVERLAY SCRIPT
       ========================================== -->
  <script>
    const API_URL = window.location.origin;
    
    const nowPlaying = document.getElementById('nowPlaying');
    const albumCover = document.getElementById('albumCover');
    const trackName = document.getElementById('trackName');
    const artistName = document.getElementById('artistName');
    const musicSource = document.getElementById('musicSource');
    
    // Audio players for playlist
    const audioPlayer = document.getElementById('audio-player');
    const audioPlayerNext = document.getElementById('audio-player-next');
    
    let activeModule = null; // 'spotify' or 'playlist'
    let lastTrack = null;
    let spotifyAvailable = false;
    let playlistAvailable = false;
    
    // Animation state
    let isVisible = false;
    let hideTimeout = null;
    
    // Playlist specific state
    let currentSong = null;
    let nextSong = null;
    let currentVolume = 50;
    let crossfadeStarted = false;
    let isPlaying = false;
    const CROSSFADE_TIME = 5; // seconds
    
    // Wake Lock to prevent sleep (keeps audio playing when minimized)
    let wakeLock = null;
    
    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          console.log('[VISUALIZER] Wake Lock acquired');
        }
      } catch (err) {
        console.warn('[VISUALIZER] Wake Lock not supported:', err);
      }
    }
    
    // Request wake lock on load
    requestWakeLock();
    
    // Re-request if visibility changes
    document.addEventListener('visibilitychange', () => {
      if (wakeLock !== null && document.visibilityState === 'visible') {
        requestWakeLock();
      }
    });
    
    // Show visualizer with slide-in animation
    function showVisualizer() {
      if (isVisible) return;
      
      isVisible = true;
      nowPlaying.classList.remove('slide-out', 'hidden');
      nowPlaying.classList.add('slide-in');
      
      // Clear any existing hide timeout
      if (hideTimeout) {
        clearTimeout(hideTimeout);
      }
      
      // Schedule hide after 10 seconds
      hideTimeout = setTimeout(() => {
        hideVisualizer();
      }, 10000);
    }
    
    // Hide visualizer with slide-out animation
    function hideVisualizer() {
      if (!isVisible) return;
      
      isVisible = false;
      nowPlaying.classList.remove('slide-in');
      nowPlaying.classList.add('slide-out');
      
      // After animation completes, hide element
      setTimeout(() => {
        if (!isVisible) {
          nowPlaying.classList.add('hidden');
        }
      }, 1000);
    }
    
    // Check which music modules are available
    async function checkMusicModules() {
      try {
        const res = await fetch(`${API_URL}/api/modules/list`);
        const data = await res.json();
        
        spotifyAvailable = data.modules.some(m => m.id === 'spotify');
        playlistAvailable = data.modules.some(m => m.id === 'playlist');
        
        console.log('[MUSIC VISUALIZER] Spotify available:', spotifyAvailable);
        console.log('[MUSIC VISUALIZER] Playlist available:', playlistAvailable);
        
        // Determine active module
        if (playlistAvailable) {
          activeModule = 'playlist';
          musicSource.textContent = 'ðŸŽµ Playlist';
          startPlaylistMode();
        } else if (spotifyAvailable) {
          activeModule = 'spotify';
          musicSource.textContent = 'ðŸŽµ Spotify';
          startSpotifyMode();
        } else {
          console.warn('[MUSIC VISUALIZER] No music modules available');
        }
      } catch (err) {
        console.error('[MUSIC VISUALIZER] Error checking modules:', err);
      }
    }
    
    // ========== PLAYLIST MODE ==========
    
    function startPlaylistMode() {
      console.log('[MUSIC VISUALIZER] Starting Playlist mode');
      updatePlaylist();
      setInterval(updatePlaylist, 1000);
      
      // Setup audio event listeners
      setupAudioListeners();
    }
    
    async function updatePlaylist() {
      try {
        const res = await fetch(`${API_URL}/api/playlist/public`);
        const data = await res.json();
        
        // Update volume
        if (data.volume !== currentVolume) {
          currentVolume = data.volume;
          audioPlayer.volume = currentVolume / 100;
          audioPlayerNext.volume = 0;
        }
        
        // Update playing state
        if (data.isPlaying !== isPlaying) {
          isPlaying = data.isPlaying;
          
          if (isPlaying) {
            audioPlayer.play().catch(e => console.error('[PLAYLIST] Play error:', e));
          } else {
            audioPlayer.pause();
            audioPlayerNext.pause();
          }
        }
        
        // Update current song
        if (data.currentSong && data.currentSong !== currentSong) {
          currentSong = data.currentSong;
          audioPlayer.src = `/music/${currentSong}`;
          audioPlayer.volume = currentVolume / 100;
          crossfadeStarted = false;
          
          if (isPlaying) {
            audioPlayer.play().catch(e => console.error('[PLAYLIST] Play error:', e));
          }
          
          console.log('[PLAYLIST] Now playing:', currentSong);
          
          // Show visualizer when new song starts
          if (data.metadata) {
            trackName.textContent = data.metadata.title;
            artistName.textContent = data.metadata.artist;
            
            // Set cover image if available
            if (data.metadata.coverUrl) {
              albumCover.innerHTML = `<img src="${data.metadata.coverUrl}" alt="Cover">`;
            } else {
              albumCover.innerHTML = 'ðŸŽµ';
            }
          } else {
            trackName.textContent = currentSong.replace(/\.(mp3|wav|ogg)$/i, '');
            artistName.textContent = 'Local Music';
            albumCover.innerHTML = 'ðŸŽµ';
          }
          
          showVisualizer();
        }
        
        // Update metadata and cover without showing visualizer
        if (data.metadata && data.isPlaying) {
          trackName.textContent = data.metadata.title;
          artistName.textContent = data.metadata.artist;
          
          // Update cover if available
          if (data.metadata.coverUrl) {
            albumCover.innerHTML = `<img src="${data.metadata.coverUrl}" alt="Cover">`;
          } else {
            albumCover.innerHTML = 'ðŸŽµ';
          }
        } else if (data.currentSong && data.isPlaying) {
          trackName.textContent = data.currentSong.replace(/\.(mp3|wav|ogg)$/i, '');
          artistName.textContent = 'Local Music';
          albumCover.innerHTML = 'ðŸŽµ';
        }
      } catch (err) {
        console.error('[PLAYLIST] Update error:', err);
      }
    }
    
    function setupAudioListeners() {
      // Crossfade logic
      audioPlayer.addEventListener('timeupdate', async () => {
        if (!isPlaying) return;
        
        const timeLeft = audioPlayer.duration - audioPlayer.currentTime;
        
        // Start crossfade 5 seconds before end
        if (timeLeft <= CROSSFADE_TIME && timeLeft > 0 && !crossfadeStarted) {
          crossfadeStarted = true;
          
          try {
            // Request next song
            const res = await fetch(`${API_URL}/api/playlist/next-song`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' }
            });
            const data = await res.json();
            
            if (data.currentSong) {
              nextSong = data.currentSong;
              audioPlayerNext.src = `/music/${nextSong}`;
              audioPlayerNext.volume = 0;
              audioPlayerNext.currentTime = 0;
              
              // Start next song
              audioPlayerNext.play().catch(e => console.error('[PLAYLIST] Next play error:', e));
              
              console.log('[PLAYLIST] Crossfade started to:', nextSong);
              
              // Fade out current, fade in next
              const fadeInterval = setInterval(() => {
                const progress = 1 - ((audioPlayer.duration - audioPlayer.currentTime) / CROSSFADE_TIME);
                
                audioPlayer.volume = Math.max(0, (currentVolume / 100) * (1 - progress));
                audioPlayerNext.volume = Math.min(currentVolume / 100, (currentVolume / 100) * progress);
                
                if (progress >= 1) {
                  clearInterval(fadeInterval);
                }
              }, 100);
            }
          } catch (err) {
            console.error('[PLAYLIST] Crossfade error:', err);
          }
        }
      });
      
      // When current song ends, switch to next
      audioPlayer.addEventListener('ended', () => {
        if (nextSong) {
          currentSong = nextSong;
          nextSong = null;
          
          // Swap players
          const tempSrc = audioPlayer.src;
          audioPlayer.src = audioPlayerNext.src;
          audioPlayerNext.src = '';
          
          audioPlayer.volume = currentVolume / 100;
          audioPlayer.currentTime = audioPlayerNext.currentTime;
          
          if (isPlaying) {
            audioPlayer.play().catch(e => console.error('[PLAYLIST] Play error:', e));
          }
          
          crossfadeStarted = false;
          
          console.log('[PLAYLIST] Switched to next song');
        } else {
          // No crossfade happened, just go to next song
          fetch(`${API_URL}/api/playlist/next-song`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          }).then(() => {
            updatePlaylist();
          }).catch(err => console.error('[PLAYLIST] Next song error:', err));
        }
      });
    }
    
    // ========== SPOTIFY MODE ==========
    
    function startSpotifyMode() {
      console.log('[MUSIC VISUALIZER] Starting Spotify mode');
      updateSpotify();
      setInterval(updateSpotify, 2000);
    }
    
    async function updateSpotify() {
      try {
        // This would need to be implemented based on your Spotify API
        // For now, just hide the overlay
        hideVisualizer();
      } catch (err) {
        console.error('[SPOTIFY] Update error:', err);
      }
    }
    
    // Initialize
    checkMusicModules();
  </script>
</body>
</html>
